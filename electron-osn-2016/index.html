<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cross Platform Applications with Electron</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="images/electron.png" style="border:0"/>
				</section>

				<section>
					<p>Aaron Ackerman</p>
					<p>twitter.com/_aaronackerman_</p>
					<p>github.com/aackerman</p>

					<aside class="notes">
						I'm Aaron Ackerman.

						You can find me on twitter and github at the addresses on these slides.

						I'm here today because I wanted to share with everybody here my experiences working with electron and shipping a product. I recently left Code 42, but while I was there I spent several months building and shipping a product through its initial and subsequent releases over the course of a year.
					</aside>
				</section>

				<section>
					<p>What is Electron?</p>

					<ul>
						<li>An interface to native APIs</li>
						<li>A collection of open source technologies</li>
						<li>An ecosystem of tools</li>
					</ul>

					<aside class="notes">
						If in the past you had heard the name Atom Shell, Electron is the exact same project with a new name.

						Electron can be described in several ways: an interface to native APIs, a collection of open source technologies, as well as an ecosystem of tools.

						That's electron in the abstract. It provides a shell to build cross platform desktop applications.

						More concretely Electron provides access to native APIs. For example, the ability to open browser windows, or access the OSX menubar or Windows systray, or create notifications through the native systems of the OS. All while allowing you the use of HTML, CSS, and JavaScript to build your user interfaces.
					</aside>
				</section>

				<section>
					<p>Competing projects</p>

					<ul>
						<li>NW.js (previously known as node-webkit)</li>
						<li>CEF (Chromium Embedded Framework)</li>
						<li>Adobe AIR</li>
						<li>Qt</li>
						<li>Java</li>
					</ul>

					<aside class="notes">
						I use the term 'competing projects' pretty liberally. For a person whose focus is on user interfaces and JavaScript the most viable other choice is NW.js.

						But I want to give these other projects some credit as viable choices for cross-platform desktop applications because they are being used by some great companies.

						`node-webkit` came first and paved the way for Electron, it's backed Intel. There are a few dozen projects on the page for `node-webkit` but none that we're notable enough that I personally knew them by name or by company.

						If you've ever played any games from Blizzard like World of Warcraft, Diablo, StarCraft or Hearthstone, the battle.net app that launches and handles updates for all of their games uses Chromium embedded framework to display views.

						If you've ever played League of Legends, their game client launcher is written in Adobe AIR.

						Qt is a library for C and C++ applications for creating user interfaces. I looked up apps that are using Qt and I was surprised to fine that the Maya product from Autodesk, which if you're unfamiliar is used to create 3d models for movies, games, and other media is built using Qt. The Tesla Model S in-car UI also uses Qt.

						As far as Java is concerned I'm sure you've heard of Eclipse. IntelliJ is also written in Java. And when I worked at Code42, the original CrashPlan desktop client was written as a cross platform desktop application in Java. There are probably countless other desktop applications using Java.

						Options do exist. If you choose to create a desktop application I'm sure you'll weigh the different options and it will depend on the expertise of the team. A team of Java engineers might choose to use Java. A team of C++ engineers might choose to use Qt or CEF. But if you have any experience with JavaScript I would bet on Electron.

						I did just that when I was at Code 42. Code 42 had an initiative to rewrite the CrashPlan desktop client using web technology. At the start of 2015 I worked on a small team, I weighed the options and I made the recommendation to engineering leadership at Code 42 to go with Electron. And that's what the company decided to use to create the interface to their flagship product. At the time I left Code 42 we had shipped the initial version along with few subsequent feature releases of the new desktop client to our enterprise customers.
					</aside>
				</section>

				<section>
					<p>Supported platforms</p>

					<ul>
						<li>OSX (>= 10.9)</li>
						<li>Windows (Windows 7 / Server 2008 R2 or higher)</li>
						<li>Linux (Ubuntu 12.04+, Fedora 21+, Debian 8+)</li>
					</ul>

					<aside class="notes">
						Platform support is pretty good, although there was disparate information about Mac. One doc said 10.8 another said 10.9. But even 10.9 is about three years old and upgrades are free.
					</aside>
				</section>

				<section>
					<p>Built with Electron</p>

					<ul>
						<li>Atom editor - Github</li>
						<li>VS Code - Microsoft</li>
						<li>Nuclide - Facebook</li>
						<li>Kitematic - Docker</li>
						<li>Slack desktop - Slack</li>
						<li>Basecamp desktop - Basecamp</li>
						<li>Wordpress desktop - Wordpress</li>
						<li>Many others...</li>
					</ul>

					<aside class="notes">
						These are some notable applications and companies that are building products using Electron.

						If you're in this room you've probably tried Atom or VS Code. And you've probably used slack. If you haven't tried any of those, you have some homework. So if you're wondering who you're jumping on the bandwagon with when you decide to use Electron you're in good company.
					</aside>
				</section>

				<section>
					<p>Challenges</p>

					<ul>
						<li>Missing APIs</li>
						<li>Cross-platform testing</li>
						<li>Platform specific bugs</li>
						<li>Security Concerns</li>
					</ul>

					<aside class="notes">
						There are challenges with Electron, like all software it is incomplete and imperfect. I want to say before this next section that overall my intention is to give Electron a glowing review. So I'm going to talk about a few challenges I went through building on Electron

						When I was building on Electron I was working with version 0.32 or something. I needed a way to only allow one instance of my application to be running at a time. Today that's a relatively easy task. Electron provides an API for that `app.makeSingleInstance`. But at the time I had to read through the docs, read through issues, figure out if it was provided and eventually write it myself. I actually cribbed most of the implementation from the Atom Editor but my point is, you might have to roll up your sleeves and get down with some native APIs. If you really have no interested in extending Electron and building from source it's possible to use node-ffi as a native module to access native APIs with the overhead of context switches between native and JavaScript.

						Cross-platform testing can be challenging depending on your organization. If you are in an organization that runs its own test infrastructure, it may be a challenge to run tests on all the platforms you want to support. You might be asking the team running infrastructure to support Windows8, Windows10, OSX, and Linux desktop. That's quite a non-trivial amount of overhead. If you're in a more progressive organization, you may be able to look at the Electron docs, and get Travis CI, Circle CI, and/or AppVeyor working immediately for every platform you need to support. So there's a spectrum there and it's depends on your company. You might also be able to say, all the features are the same on all platforms only test on linux and let your users create support tickets. As always, there are tradeoffs to consider.

						I've also run into a few platform specific bugs. When the bug was filed it was often something like, 'Sometimes this happens on Windows.'

						In one case we had a menubar icon on OSX that would open a window to display and it had background transparency. In rare, seemingly unreproducible cases, when the window was opened the portions that were intended to be transparent were completely white. The solution for us was to remove the transparency and work around that specific issue.

						In another case we ran into a bug where the application menu on OSX could become unresponsive in some situations until you clicked out of the application into another application and then clicked back. I checked through the application code, I looked through the electron code, and eventually tracked this down to a bug in OSX itself. And we submitted a patch upstream to Electron to work around the issue. So even when your code is fine, Electron's code is fine, you might run into problems with the OS.

						As far as security is concerned it's important to do right by your consumers. The Electron docs have a great article about security and the issues that arise with opting out of security that is provided by default. Security is even more important in Electron because a cross-site scripting vulnerability could allow an attacker take over your users computer. It's also necessary to be mindful of the security of chromium itself. Electron updates its dependent components in good time, but some security concerns should be address in hours, and not in terms of days or weeks. There is that aspect to consider if you are extremely security conscious.
					</aside>
				</section>

				<section>
					<p>What's great</p>

					<ul>
						<li>Documentation</li>
						<li>Support</li>
						<li>Versioning and Deprecations</li>
						<li>One runtime</li>
					</ul>

					<aside class="notes">
						The ecosystem around Electron is great. That is in large part due to the extremely dedicated employees at Github along with the rest of the community. It's really easy to have bad documentation. It's even easier to have no documentation. But the maintainers of Electron seem to pride themselves on the quality and consistency of there documentation and it really helps the project shine.

						When I was initially evaluating Electron. I looked at the quick start documentation and I had an application running on my desktop within the span of five minutes. And it was more complicated then, I had to download a build of Electron, copy/paste a package.json, index.html, and main.js, then figure out how to run the project. Today you could have this in 4 commands, clone the quick start repo, cd into it, `npm install` and `npm start`.

						The support from the maintainers is fantastic as well. I've filed several issues on the Electron repo, 5 of them confirmed as real bugs, with only one of them still open probably because it's easy to workaround and all of the other issues I've filed we're answered promptly and professionally.

						Electron follows semver as far as I can tell, I haven't seen any major issues with breaking changes that have not been documented or were not bugs. In addition to documenting deprecations warnings are logged when the application uses deprecated APIs. It was easy for me to update from deprecated APIs to use new APIs by searching through the documentation and the electron source for which APIs had been deprecated and changing the code for application I was working on.

						One of the best things about working with Electron is the support for one runtime. You essentially have browser windows that are capable of running the same JavaScript of Chrome stable. Electron 1.2.2 is running Chrome 51 and Node 6.1. So you can use very nearly every feature of ES2015 without using Babel compilation. You'll still have to use Babel if you're using React or you are interested in having future facing features like object rest/spread operators. But you don't have to worry about what kind of browser the user is running because you know exactly which version and the capabilities of it when you build it.
					</aside>
				</section>

				<section>
					<section>
						<p>Electron Architecture</p>
					</section>

					<section>
						<img src="images/electron-architecture.png" style="border:0;background:transparent; box-shadow:none">

						<aside class="notes">
							Electron employs a very similar architecture that you see in Chrome desktop. One master process is a controller for several other processes. The main process runs in the background and doesn't have any visuals. The job of the main process is to control the lifecycle of the application, display windows, display menus, and handle events dispatched from Electron. The main process opens a browser window and at that point each process is sandboxed from the other process. Communication between windows and the main process happens through IPC messaging, if you haven't heard of IPC it's short for inter-process communication. Messages can be sent sync of async, but as with all JavaScript you're blocking the event loop when doing synchronous work so it's better to keep all messaging async.
						</aside>
					</section>

					<section>
						<p>Main process vs Renderer process capabilities</p>

						<img
							src="images/electron-main-process.png"
							style="
								border: 0;
						    display: inline-block;
						    width: 30%;
						">

						<img
							src="images/electron-renderer-process.png"
							style="
								border: 0;
						    display: inline-block;
						    width: 32.7%;
						">

						<aside class="notes">
							These are all of the high level capabilities for the two different types of processes that can fit on this slide. There are a few cut off, but if I made the images any smaller you couldn't read them.
						</aside>
					</section>

				</section>

				<section>
					<p>The Ecosystem of Electron Tools</p>
				</section>

				<section>
					<section>
						Ecosystem of tools
					</section>

					<section>
						electron-prebuilt
					</section>

					<section>
						electron-packager
					</section>

					<section>
						Devtron
						<img src="images/devtron.png">
					</section>

					<section>
						Spectron
						<img src="images/spectron.png">
					</section>
				</section>

				<section>
					<h2>Questions?</h2>
					<br><br><br>
					<p>Aaron Ackerman</p>
					<p>twitter.com/_aaronackerman_</p>
					<p>github.com/aackerman</p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
